### 解题思路
官方题解已经提供了四种方法，我在这里主要就第三种 **环状替代** 方法做一下图解，希望能帮助到没理解的朋友
我们假设现在有 `A 、B 、C、 D、 E `五名同学，今天考试完，老师要求换座位，每个同学向后移动`3`个座位
于是就从 A 同学开始换座位了... （**下图左边**）
1. **A同学** 非常自觉，看了看自己座位号（**0**），根据老师要求，他走到了**3 号位置**，即 D 同学的位置，同时他把D 同学赶到了角落，自己坐在了 **3 号位置**，第一个完成任务真爽！
2. **D同学** 一看，不行啊，我咋能呆在角落，于是D同学也按要求理直气壮来到了**1号位置**，同样把B同学赶到了角落，猛男落泪...
3. **B同学** 当然也不干，气汹汹走到了**4号位置**，"E同学，麻烦起来一下，角落给你收拾好了：)",于是 E同学来到角落..
4. **E同学** 一想：不行呀，我这么帅，必须有座位！站起来跑到了**2号位置**，二话不说，赶走了C，坐上上去，一下子舒服了...
5. **C同学** 此时来了角落，想：不是每个人都有座位吗？？还需要抢？于是C从容的来到了**0号位置**，至此，所有同学都坐好了。

以上是 **下图中左边** 的情况，这个算法还会遇到另外一种情况，就是今天E同学请假，老师说那就每个人往后移动 2个座位。于是大家开始行动，和上面发生的一样，不过，当第二轮**C同学**坐好了以后，角落没人了，大家都有位子，就没人闹意见了...
老师一看，我精心布置的局，咋就停了呢，于是吼了一嗓子："咳咳！还有谁没换？第二组打头的那个！**B同学**！是不是你！你们第二组学学第一组，第一组早早的换完了，你们组还一个没动！"
B同学一听到喊自己的名字，秒怂...本来想偷懒，无奈换起来座位..就这样，随着第二组的同学换完座位，最终大家完成了换座位
(**上面老师喊的那一嗓子，就是我们内循环退出，即C回到了起始位置0位置，这时候我们就将起始位置 Start + 1**)

![图片.png](https://pic.leetcode-cn.com/ffdad22d3d8e615e889cbfa8d60a51f207a8eab1926416723a9594b7d3774cb0-%E5%9B%BE%E7%89%87.png)

###  （补充）关于上述两种情况何时出现：
其实是这样的，对于一个长度为 *n* 的数组，整体移动 *k* 个位置
- 当 *n* 和 *k* 的最大公约数 **等于** 1 的时候：1 次遍历就可以完成交换；比如 *n = 5, k = 3* 
- 当 *n* 和 *k* 的最大公约数 **不等于** 1 的时候：1 次遍历是无法完成的所有元素归位，需要 *m* (最大公约数) 次

所以在最大公约数不为 1 的时候
比如 *[A,B,C,D,E,F]*  此时 ![n=6\,k=4 ](./p__n_=_6__,_k_=_4_.png)  ，其最大公约数为 *2* ,因此需要 *2* 轮循环
我们就可以把这个数组分成两部分来看：
第 *1* 轮循环（分组1）： ![A\E\C\\[A\] ](./p__A__E__C___A__.png)      
第 *2* 轮循环（分组2）：     ![\\\\B\F\D\\[B\] ](./p______B__F__D___B__.png)   
* **即**：每一轮循环只会在自己的那一组上不停的遍历。所以
**数组的前 *m* 个元素，其实就是每一个分组的第一个元素，我们控制流程在每次发现一轮循环走到原点时+1**

* 那么如何判断所有的分组都执行归位了呢？ 可以有两种方法来控制
    > 第一种：我们就用最大公约数 *m* 来控制外循环，代表总共有 *m* 轮循环
    > 第二种：由于*n*个元素归位需要*n*次交换，所以我们定义一个count代表交换次数，当 count = n 时完成

### 代码

```java
class Solution {
    public void rotate(int[] nums, int k) {
       int len  = nums.length;
       k = k % len;
       int count = 0;         // 记录交换位置的次数，n个同学一共需要换n次
        for(int start = 0; count < len; start++) {
            int cur = start;       // 从0位置开始换位子
            int pre = nums[cur];   
            do{
                int next = (cur + k) % len;
                int temp = nums[next];    // 来到角落...
                nums[next] = pre;
                pre = temp;
                cur = next;
                count++;
            }while(start != cur)  ;     // 循环暂停，回到起始位置，角落无人
             
        }   
    }  
}
```

